using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using MayhemCore;
using MayhemSerial;
using Timer = System.Timers.Timer;

namespace ArduinoModules.Firmata
{
    /// <summary>
    /// Manages and reads the state of an Arduino running the Firmata Firmware.
    /// Serial communications backend is MayhemSerial.
    /// 
    /// More info on Firmata:                http://firmata.org/wiki/Main_Page  
    /// More info on the Firmata Procol:     http://www.firmata.org/wiki/V2.2ProtocolDetails
    /// </summary>
    public class ArduinoFirmata : ISerialPortDataListener
    {
        private static readonly Dictionary<string, ArduinoFirmata> Instances = new Dictionary<string, ArduinoFirmata>();

        private static readonly MayhemSerialPortMgr Serial = MayhemSerialPortMgr.Instance;

        // name of the serial port
        private readonly string portName;             

        public string PortName
        {
            get { return portName; }
        }

        private bool initialized;

        // parsing
        private readonly byte[] parseBuf;
        private int parseCommandLen;
        private int parseCount;

        private string firmataName;

        // pin information 
        private readonly Pin[] pinInfo;

        // state change events
        public event EventHandler OnInitialized;

        public event Action<Pin> OnPinAdded;

        public event Action<Pin> OnAnalogPinChanged;

        public event Action<Pin> OnDigitalPinChanged;

        private AsyncOperation operation;

        private Timer readPinsTimer;

        private ArduinoFirmata(string serialPortName)
        {
            readPinsTimer = new Timer(20);
            parseBuf = new byte[8192];
            pinInfo = new Pin[128];
            operation = AsyncOperationManager.CreateOperation(null);

            if (Serial.ConnectPort(serialPortName, this, new ArduinoFirmataSerialSettings()))
            {
                portName = serialPortName;
                InitializeFirmata();
            }
        }

        /// <summary>
        /// Returns true if an initialized Arduino Instance is already connected to the port with serialPortName. 
        /// </summary>
        /// <param name="serialPortName"></param>
        /// <returns></returns>
        public static bool InstanceExists(string serialPortName)
        {
            if (Instances.Keys.Contains(serialPortName) &&
                Instances[serialPortName] != null &&
                Instances[serialPortName].initialized)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Registers an Arduino Event Listener
        /// </summary>
        /// <param name="l"></param>
        public void RegisterListener(IArduinoEventListener l)
        {
            // subtract listeners first to suppress multi-listener registration
            OnAnalogPinChanged -= l.Arduino_OnAnalogPinChanged;
            OnDigitalPinChanged -= l.Arduino_OnDigitalPinChanged;
            OnInitialized -= l.Arduino_OnInitialized;
            OnPinAdded -= l.Arduino_OnPinAdded;

            OnAnalogPinChanged += l.Arduino_OnAnalogPinChanged;
            OnDigitalPinChanged += l.Arduino_OnDigitalPinChanged;
            OnInitialized += l.Arduino_OnInitialized;
            OnPinAdded += l.Arduino_OnPinAdded;
        }

        /// <summary>
        /// Deregisters an Arduino Event Listener
        /// </summary>
        /// <param name="l"></param>
        public void DeregisterListener(IArduinoEventListener l)
        {
            // subtract listeners first to suppress multi-listener registration
            OnAnalogPinChanged -= l.Arduino_OnAnalogPinChanged;
            OnDigitalPinChanged -= l.Arduino_OnDigitalPinChanged;
            OnInitialized -= l.Arduino_OnInitialized;
            OnPinAdded -= l.Arduino_OnPinAdded;
        }

        /// <summary>
        /// Allow only one instance per port name, generated by this factory method.
        /// </summary>
        /// <param name="serialPortName"></param>
        /// <returns>Initialized instance of Arduino bound to specified port name.</returns>
        public static ArduinoFirmata InstanceForPortname(string serialPortName)
        {
            Logger.WriteLine("InstanceForPortname");
            if (!string.IsNullOrEmpty(serialPortName))
            {
                if (Instances.Keys.Contains(serialPortName) && Instances[serialPortName] != null)
                {
                    return Instances[serialPortName];
                }
                else
                {
                    Dictionary<string, string> portNames = Serial.GetArduinoPortNames();

                    if (portNames.Keys.Contains(serialPortName))
                    {
                        Logger.WriteLine("creating new instance for port " + serialPortName);
                        Instances[serialPortName] = new ArduinoFirmata(serialPortName);
                        return Instances[serialPortName];
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// Sends initial Firmata message and initialize the mcu state
        /// </summary>
        private void InitializeFirmata()
        {
            // initialize pin info
            for (int i = 0; i < 128; i++)
            {
                pinInfo[i] = new Pin();
                pinInfo[i].Mode = PinMode.Unassigned;
                pinInfo[i].AnalogChannel = 127;
                pinInfo[i].SupportedModes = 0;
                pinInfo[i].Value = 0;
                pinInfo[i].Id = i;
                pinInfo[i].Flagged = false;
            }

            // send handshake
            byte[] buf = new byte[3] { FirmataMsg.StartSysex, FirmataMsg.ReportFirmware, FirmataMsg.EndSysex };
            Serial.WriteToPort(portName, buf, 3);

            SetSamplingInterval(100);
        }

        private void readPinsTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
        {
            QueryPins(32);
        }

        public void SetSamplingInterval(UInt16 interval)
        {
            byte[] ms = new byte[2];
            ms[0] = (byte)(interval & (UInt16)0xff);
            ms[1] = (byte)((interval) >> 8);

            byte[] message = new byte[5] { FirmataMsg.StartSysex, FirmataMsg.SamplingInterval, ms[0], ms[1], FirmataMsg.EndSysex };
            Serial.WriteToPort(portName, message, message.Length);
        }

        #region Outgoing commands

        /// <summary>
        /// Public Exposure of QueryPins
        /// </summary>
        public void QueryPins()
        {
            QueryPins(64);
        }

        /// <summary>
        /// Queries pins upto certain index
        /// </summary>
        /// <param name="upto"></param>
        private void QueryPins(int upto)
        {
            int pin = 0;

            // send a state query for for every pin with any modes
            for (pin = 0; pin < upto; pin++)
            {
                byte[] buf = new byte[512];
                int len = 0;
                if (pinInfo[pin].SupportedModes > 0)
                {
                    buf[len++] = FirmataMsg.StartSysex;
                    buf[len++] = FirmataMsg.PinStateQuery;
                    buf[len++] = (byte)pin;
                    buf[len++] = FirmataMsg.EndSysex;
                }

                Serial.WriteToPort(portName, buf, len);
            }
        }

        /// <summary>
        /// Public DigitalWrite exposure (for the time being) 
        /// </summary>
        /// <param name="pinIndex"></param>
        /// <param name="val"></param>
        public void DigitalWrite(int pinIndex, int val)
        {
            // retrieve the pin to write to from the index
            if (pinIndex >= 0 && pinIndex <= 128)
            {
                Pin writePin = pinInfo[pinIndex];
                DigitalWrite(writePin, val);
            }
        }

        /// <summary>
        /// Sets the logic value of the pin 
        /// </summary>
        /// <param name="p"></param>
        /// <param name="value"></param>
        private void DigitalWrite(Pin p, int value)
        {
            pinInfo[p.Id].Value = value;
            byte[] buf = new byte[3];
            int portNumber = (p.Id >> 3) & 0x0F;
            UInt16 port_val = 0;
            for (int i = 0; i < 8; i++)
            {
                int idx = (portNumber * 8) + i;
                if (p.Mode == PinMode.Output || p.Mode == PinMode.Input)
                {
                    if (pinInfo[i].Value > 0)
                    {
                        port_val |= (UInt16)(1 << i);
                    }
                }
            }

            buf[0] = (byte)(0x90 | portNumber);
            buf[1] = (byte)(port_val & 0x7f);
            buf[2] = (byte)((port_val >> 7) & 0x7f);

            Serial.WriteToPort(portName, buf, 3);
        }

        /// <summary>
        /// Set the pin mode to one of the supported modes
        /// The pin mode change message consists of three bytes 
        /// --- 
        /// 0xF4 pin change command
        /// pin byte
        /// mode byte
        /// ---
        /// </summary>
        /// <param name="p"></param>
        /// <param name="mode"></param>
        public void SetPinMode(Pin p, PinMode mode)
        {
            pinInfo[p.Id].Mode = mode;

            // flag this pin as an output pin (?)
            if (mode == PinMode.Output)
                pinInfo[p.Id].Flagged = true;

            byte[] buf = new byte[3] { FirmataMsg.PinModeSet, (byte)p.Id, (byte)mode };
            Serial.WriteToPort(portName, buf, buf.Length);
        }

        #endregion

        /// <summary>
        /// Notfication from the serial port manager when serial data is available
        /// </summary>
        public void DataReceived(string portName, byte[] buffer, int numBytes)
        {
            // Logger.WriteLine("port_DataReceived");

            // make a local deep copy of the RX buffer
            byte[] buf = new byte[numBytes];
            Array.Copy(buffer, buf, numBytes);

            int nBytes = numBytes;
            if (nBytes > 0)
            {
                // determine the message type
                for (int i = 0; i < nBytes; i++)
                {
                    byte msn = (byte)(buf[i] & 0xf0);
                    if (msn == FirmataMsg.AnalogIoMessage || msn == FirmataMsg.DigitalIoMessage || buf[i] == (byte)0xf9)
                    {
                        parseCommandLen = 3;
                        parseCount = 0;
                    }
                    else if (msn == FirmataMsg.ReportAnalogPin || msn == FirmataMsg.ReportDigitalPort)
                    {
                        parseCommandLen = 2;
                        parseCount = 0;
                    }
                    else if (buf[i] == FirmataMsg.StartSysex)
                    {
                        parseCount = 0;
                        parseCommandLen = parseBuf.Length;
                    }
                    else if (buf[i] == FirmataMsg.EndSysex)
                    {
                        parseCommandLen = parseCount + 1;
                    }
                    else if ((buf[i] & (byte)(0x80)) == 1)
                    {
                        parseCommandLen = 1;
                        parseCount = 0;
                    }

                    // ? 
                    if (parseCount < parseBuf.Length)
                    {
                        parseBuf[parseCount++] = buf[i];
                    }
                    else
                    {
                        break;
                    }

                    if (parseCount == parseCommandLen)
                    {
                        // parse the message
                        ProcessMessage();
                        parseCount = 0;
                        parseCommandLen = 0;
                    }
                }
            }
        }

        private void ProcessMessage()
        {
            byte cmd = (byte)(parseBuf[0] & (byte)0xF0);

            if (cmd == FirmataMsg.AnalogIoMessage && parseCount == 3)
            {
                int analog_ch = (parseBuf[0] & 0x0F);
                int analog_val = parseBuf[1] | (parseBuf[2] << 7);
                for (int pin = 0; pin < 128; pin++)
                {
                    if (pinInfo[pin].AnalogChannel == analog_ch)
                    {
                        pinInfo[pin].Value = analog_val;

                        // event callbacks
                        if (this.OnAnalogPinChanged != null)
                        {
                            OnAnalogPinChanged(pinInfo[pin]);
                        }

                        return;
                    }
                }
            }

            if (cmd == FirmataMsg.DigitalIoMessage /*&& parse_count == 3*/)
            {
                int port_num = (parseBuf[0] & (byte)0x0F);
                int port_val = parseBuf[1] | (parseBuf[2] << 7);
                int pin = port_num * 8;

                // basically: go through the bits in the register and mask with 1
                for (; pin < 128; pin++)
                {
                    if (pinInfo[pin].Mode == PinMode.Input)
                    {
                        int val = 0;
                        if (((port_val >> pin) & 1) == 1)
                        {
                            val = 1;
                        }
                        else
                        {
                            val = 0;
                        }

                        Logger.WriteLine("pin " + pin + " val " + val);
                        if (pinInfo[pin].Value != val)
                        {
                            pinInfo[pin].Value = val;

                            // event callbacks
                            if (this.OnDigitalPinChanged != null)
                            {
                                OnDigitalPinChanged(pinInfo[pin]);
                            }
                        }
                    }
                }

                return;
            }

            if (parseBuf[0] == FirmataMsg.StartSysex && parseBuf[parseCount - 1] == FirmataMsg.EndSysex)
            {
                // Sysex message
                if (parseBuf[1] == FirmataMsg.ReportFirmware)
                {
                    char[] name = new char[parseCount - 5];
                    int len = 0;
                    for (int i = 4; i < parseCount - 2; i += 2)
                    {
                        name[len++] = Convert.ToChar(((parseBuf[i] & 0x7F)
                          | ((byte)(parseBuf[i + 1] & (byte)(0x7F)) << 7)));
                    }

                    name[len++] = '-';
                    name[len++] = Convert.ToChar(parseBuf[2] + '0');
                    name[len++] = '.';
                    name[len++] = Convert.ToChar(parseBuf[3] + '0');
                    name[len++] = Convert.ToChar(0);
                    firmataName = new string(name);

                    // consider Arduino initialized if it has a new name
                    this.initialized = true;
                    if (this.OnInitialized != null)
                    {
                        OnInitialized(this, null);
                    }

                    // query the board's capabilities only after hearing the
                    // REPORT_FIRMWARE message.  For boards that reset when
                    // the port open (eg, Arduino with reset=DTR), they are
                    // not ready to communicate for some time, so the only
                    // way to reliably query their capabilities is to wait
                    // until the REPORT_FIRMWARE message is heard.
                    byte[] buf = new byte[80];
                    len = 0;
                    buf[len++] = FirmataMsg.StartSysex;
                    buf[len++] = FirmataMsg.AnalogMappingQuery; // read analog to pin # info
                    buf[len++] = FirmataMsg.EndSysex;
                    buf[len++] = FirmataMsg.StartSysex;
                    buf[len++] = FirmataMsg.CapabilityQuery; // read capabilities
                    buf[len++] = FirmataMsg.EndSysex;
                    for (int i = 0; i < 16; i++)
                    {
                        buf[len++] = (byte)(0xC0 | i);  // report analog
                        buf[len++] = 1;
                        buf[len++] = (byte)(0xD0 | i);  // report digital
                        buf[len++] = 1;
                    }

                    Serial.WriteToPort(portName, buf, len);
                }
                else if (parseBuf[1] == FirmataMsg.CapabilityResponse)
                {
                    int pin, i, n;
                    for (pin = 0; pin < 128; pin++)
                    {
                        pinInfo[pin].SupportedModes = 0;
                    }

                    for (i = 2, n = 0, pin = 0; i < parseCount; i++)
                    {
                        if (parseBuf[i] == 127)
                        {
                            pin++;
                            n = 0;
                            continue;
                        }

                        if (n == 0)
                        {
                            // first byte is supported mode
                            pinInfo[pin].SupportedModes |= ((ulong)1 << parseBuf[i]);
                        }

                        n = n ^ 1;
                    }

                    // send a state query for for every pin with any modes
                    for (pin = 0; pin < 128; pin++)
                    {
                        byte[] buf = new byte[512];
                        int len = 0;
                        if (pinInfo[pin].SupportedModes > 0)
                        {
                            buf[len++] = FirmataMsg.StartSysex;
                            buf[len++] = FirmataMsg.PinStateQuery;
                            buf[len++] = (byte)pin;
                            buf[len++] = FirmataMsg.EndSysex;
                        }

                        Serial.WriteToPort(portName, buf, len);
                    }
                }
                else if (parseBuf[1] == FirmataMsg.AnalogMappingResponse)
                {
                    int pin = 0;
                    for (int i = 2; i < parseCount - 1; i++)
                    {
                        pinInfo[pin].AnalogChannel = parseBuf[i];
                        pin++;
                    }

                    return;
                }
                else if (parseBuf[1] == FirmataMsg.PinStateResponse && parseCount >= 6)
                {
                    int pin = parseBuf[2];
                    pinInfo[pin].Mode = (PinMode)parseBuf[3];
                    pinInfo[pin].Value = parseBuf[4];
                    if (parseCount > 6) pinInfo[pin].Value |= (byte)(parseBuf[5] << 7);
                    if (parseCount > 7) pinInfo[pin].Value |= (byte)(parseBuf[6] << 14);
                    Logger.WriteLine("Added Pin! " + pin + " " + pinInfo[pin].Mode + " " + pinInfo[pin].Value);

                    /////////////////////// post asynchronous event on main thread
                    if (this.OnPinAdded != null)
                    {
                        OnPinAdded(pinInfo[pin]);
                    }
                }

                return;
            }
        }
    }
}
